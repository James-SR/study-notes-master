# Joining Data in PostgreSQL
***
Notes taken during/inspired by the Datacamp course 'Joining Data in PostgreSQL' by Chester Ismay. 

Course sections:

* Part 1 - Introduction to joins
* Part 2 - Outer joins and cross joins
* Part 3 - Set theory clauses
* Part 4 - Subqueries
* [Additional - Join Cheat Sheet](http://stevestedman.com/vzAph)

```{r setup}
library(RPostgreSQL)

# create a connection
# save the password that we can "hide" it as best as we can by collapsing it
pw <- {"PASSWORD"}

# loads the PostgreSQL driver
drv <- dbDriver("PostgreSQL")
# creates a connection to the postgres database
# note that "con" will be used later in each connection to the database
con <- dbConnect(drv, dbname = "countries",
                 host = "localhost", port = 5432,
                 user = "postgres", password = pw)
rm(pw) # removes the password

# Sets knitr to use this connection as the default so we don't need to specify it for every chunk
knitr::opts_chunk$set(connection = "con")
```


## Introduction to joins

Throughout this course, we will be working with the countries database containing information about the most populous world cities as well as country-level economic data, population data, and geographic data. This countries database also contains information on languages spoken in each country.  OUr basic syntax for joins is:

> SELECT *
  FROM left_table
  INNER JOIN right_table
  ON left_table.id = right_table.id;
  
So to (inner) join cities (left) and countries (right) together we have 

```{sql connection=con}
SELECT * 
FROM cities
INNER JOIN countries
ON cities.country_code = countries.code
LIMIT 10;
```

Or to just select the columns you are interested in and alias the names in to something more useful

```{sql connection=con}
SELECT cities.name AS city, countries.name AS country, countries.region 
FROM cities
INNER JOIN countries
ON cities.country_code = countries.code
LIMIT 10;
```

Instead of writing the full table name, you can use table aliasing as a shortcut. For tables you also use AS to add the alias immediately after the table name with a space. Check out the aliasing of cities and countries below.

> SELECT c1.name AS city, c2.name AS country
  FROM cities AS c1
  INNER JOIN countries AS c2
  ON c1.country_code = c2.code;

Notice that to select a field in your query that appears in multiple tables, you'll need to identify which table/table alias you're referring to by using a . in your SELECT statement.

Now we look at how to get data from both the countries and economies tables to examine the inflation rate for both 2010 and 2015.

```{sql connection=con}
SELECT c.code AS country_code, c.name, e.year, e.inflation_rate
FROM countries AS c
INNER JOIN economies AS e
ON c.code = e.code
LIMIT 20;
```

To get the fertility rate over time

```{sql connection=con}
SELECT c.code, c.name, c.region, p.year, p.fertility_rate, p.country_code
FROM countries AS c
INNER JOIN populations AS p
ON c.code = p.country_code
LIMIT 20;
```

Then to add in the unemployment rate

```{sql connection=con}
SELECT c.code, c.name, c.region, p.year, p.fertility_rate, p.country_code, e.year, e.unemployment_rate
FROM countries AS c
INNER JOIN populations AS p
ON c.code = p.country_code
INNER JOIN economies AS e
ON c.code = e.code
LIMIT 20;
```

The results are not correct here, as the join on c.code = e.code whilst not also including year causes a cross join e.g. the 2010 value for fertility_rate is also paired with the 2015 value for unemployment_rate. Let's correct that by joining on CODE and YEAR.

```{sql connection=con}
SELECT c.code, c.name, c.region, p.year, p.fertility_rate, p.country_code, e.year, e.unemployment_rate
FROM countries AS c
INNER JOIN populations AS p
ON c.code = p.country_code
INNER JOIN economies AS e
ON c.code = e.code AND p.year = e.year
LIMIT 20;
```

When two tables contain the same field, it is possible to use the USING command rather than ON to join the two tables.  

```{sql}
SELECT c.name AS country, continent, l.name AS language, official
FROM countries AS c
INNER JOIN languages AS l
USING (code)
LIMIT 20;
```

Sometimes we want to join a table to iself, to see different permeatations of columns and variables, which is called a self-join.

Now we will use the populations table to perform a self-join to calculate the percentage increase in population from 2010 to 2015 for each country code.

As we will be joining the populations table to itself, we can alias populations as p1 and also populations as p2. This is good practice whenever you are aliasing and your tables have the same first letter. Note that you are required to alias the tables with self-joins.

```{sql connection=con}
SELECT p1.country_code, 
       p1.size AS size2010,
       p2.size AS size2015
FROM populations AS p1
INNER JOIN populations AS p2
ON  p1.country_code = p2.country_code
LIMIT 30;
```

Notice from the result that for each country_code you have four entries laying out all combinations of 2010 and 2015.  This is similar to a cross join or cartesian join where every combination of variables is made.  

To remedy this, we add to the ON to the query to include only those records where the p1.year (2010) matches with p2.year - 5 (2015 - 5 = 2010).

```{sql connection=con}
SELECT p1.country_code, 
       p1.size AS size2010,
       p2.size AS size2015
FROM populations AS p1
INNER JOIN populations AS p2
ON  p1.country_code = p2.country_code AND p1.year = p2.year - 5
LIMIT 30;
```

Next we can calculate the change over time by calculating a new field.

```{sql connection=con}
SELECT p1.country_code, 
       p1.size AS size2010,
       p2.size AS size2015,
       (p2.size - p1.size) / p1.size * 100 AS growth_perc 
FROM populations AS p1
INNER JOIN populations AS p2
ON  p1.country_code = p2.country_code AND p1.year = p2.year - 5
LIMIT 30;
```


Another scenario is when we want to create a group or category within our data.  We can do this using the CASE function, which is similar to a series of IF then functions, where if a condition is met, a variable (column) is assigned a value or name.  This process is then iterated until we remain with our final ELSE component.  

You can use CASE with WHEN, THEN, ELSE, and END to define a new grouping field.

```{sql connection=con}
-- get name, continent, code, and surface area
SELECT name, continent, code, surface_area,
    -- first case
    CASE WHEN surface_area > 2000000
    -- first then
            THEN 'large'
    -- second case
       WHEN surface_area > 350000
    -- second then
            THEN 'medium'
    -- else clause + end
       ELSE 'small' END
    -- alias resulting field of CASE WHEN
       AS geosize_group
-- from the countries table
FROM countries
LIMIT 10;
```

If we wanted to create a new table, we could use the INTO command

```{sql connection=con, echo = FALSE}
SELECT name, continent, code, surface_area,
    CASE WHEN surface_area > 2000000
            THEN 'large'
       WHEN surface_area > 350000
            THEN 'medium'
       ELSE 'small' END
       AS geosize_group
INTO countries_plus
FROM countries;
```

We will now explore the relationship between the size of a country in terms of surface area and in terms of population using grouping fields created with CASE, focusing on just 2015.  We will save the results in to a new table, pop_plus.

```{sql connection=con}
SELECT country_code, size,
    CASE WHEN size > 50000000
            THEN 'large'
        WHEN size > 1000000
            THEN 'medium'
        ELSE 'small' END
        AS popsize_group
INTO pop_plus
FROM populations
-- any conditions to check?
WHERE year = 2015;
```


Now we will join countries_plus to pop_plus and order our results based on geosize_group so the largest appear at the top.

```{sql connection=con}
SELECT c.name, c.continent, c.geosize_group, c.code, p.popsize_group, p.country_code
FROM countries_plus AS c
INNER JOIN pop_plus AS p
ON  c.code = p.country_code
ORDER BY geosize_group
LIMIT 25;
```

## Outer joins and cross joins

Outer joins can be thought of as 'reaching out' to another tables, whilst keeping all of the records from the original table.  Inner joins only keep the records IN both tables.  

* A left join will add data from the right table, to that on the left (the original) and mark and variables not in the right table as missing
* A right join is much less common than the left join.  We add fields from the left table to that on the right, leaving missing values where needed

In the next examples we will compare an inner join to a left join

```{sql connection=con}
SELECT c1.name AS city, code, c2.name AS country,
       region, city_proper_pop
-- specify left table
FROM cities AS c1
-- specify right table and type of join
INNER JOIN countries AS c2
-- how should the tables be matched
ON c1.country_code = c2.code
-- sort based on descending country code
ORDER BY code DESC;
```

There are 230 rows here.  Next, we will use a left join

```{sql connection=con}
SELECT c1.name AS city, code, c2.name AS country,
       region, city_proper_pop
-- specify left table
FROM cities AS c1
-- specify right table and type of join
LEFT JOIN countries AS c2
-- how should the tables be matched?
ON c1.country_code = c2.code
-- sort based on descending country code
ORDER BY code DESC;
```

We now have 236 rows and we can see that there are some cities  which are not matching corresponding results in the countries table.

Now we will use the use of the AVG() function introduced in our Intro to SQL for Data Science course. we will use it in combination with left join to determine the average gross domestic product (GDP) per capita by region in 2010, grouped by region/

```{sql connection=con}
-- select name, region, and gdp_percapita
SELECT region, AVG(gdp_percapita) AS avg_gdp
-- countries (alias c) on the left
FROM countries AS c
-- join with economies (alias e)
LEFT JOIN economies AS e
-- match on code fields
ON c.code = e.code
-- focus on 2010 entries
WHERE year = 2010
GROUP BY region
ORDER BY avg_gdp DESC;
```

Right joins are not as common as left joins, because in part, a right join can always be written as a left join.

```{sql connection=con}
-- Right Join
SELECT cities.name AS city, urbanarea_pop, countries.name AS country,
       indep_year, languages.name AS language, percent
FROM languages
RIGHT JOIN countries
ON languages.code = countries.code
RIGHT JOIN cities
ON countries.code = cities.country_code
ORDER BY city, language
LIMIT 20;

/*
The Left Join would look like
SELECT cities.name AS city, urbanarea_pop, countries.name AS country,
       indep_year, languages.name AS language, percent
FROM cities
LEFT JOIN countries
ON cities.country_code = countries.code
LEFT JOIN languages
ON countries.code = languages.code
ORDER BY city, language
LIMIT 20;
*/
```

So far we have encountered 3 join types, now we look at Full Joins, which is similar to combining a LEFT and a RIGHT join together.

```{r JoinTypes, echo = FALSE, fig.cap='Inner, Left, Right and Full Joins'}
knitr::include_graphics("images/JoinTYpes.png")
```
