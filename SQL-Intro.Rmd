# SQL for Data Science
***
Notes taken during/inspired by the Datacamp course 'Intro to SQL for Data Science' by Nick Carchedi. 

Course sections:

* Part 1 - Selecting columns
* Part 2 - Filtering rows
* Part 3 - Aggregate Functions
* Part 4 - Sorting, grouping and joins
* [Additional - KD Nuggets Overview and courses](https://www.kdnuggets.com/2016/06/seven-steps-mastering-sql-data-science.html)


## Selecting columns

SQL is the native language for interacting with databases (RDBMS).  Many non-SQL systems, such as Hadoop and Spark, will often have a SQL above to make extracting and analysing possible.   

```{r setup}
library(RPostgreSQL)

# create a connection
# save the password that we can "hide" it as best as we can by collapsing it
pw <- {"PASSWORD"}

# loads the PostgreSQL driver
drv <- dbDriver("PostgreSQL")
# creates a connection to the postgres database
# note that "con" will be used later in each connection to the database
con <- dbConnect(drv, dbname = "films",
                 host = "localhost", port = 5432,
                 user = "postgres", password = pw)
rm(pw) # removes the password

# Sets knitr to use this connection as the default so we don't need to specify it for every chunk
knitr::opts_chunk$set(connection = "con")
```

We can take a look at the first ten rows using - note that SQL is NOT case sensitive, however it is good practice to make SQL keywords uppercase to distinguish them from other parts of your query, like column and table names.

It's also good practice (but not necessary for the exercises in this course) to include a semicolon at the end of your query. This tells SQL where the end of your query is.

```{sql}
SELECT name FROM people
LIMIT 10;
```

If multiple columns are needed we use a comma after each field, or if all columns are needed we use SELECT *

```{sql}
SELECT title, release_year, country
FROM films
LIMIT 10;

SELECT *
FROM films
LIMIT 10;
```

Often your results will include many duplicate values. If you want to select all the unique values from a column, you can use the DISTINCT keyword.

```{sql}
SELECT DISTINCT certification
FROM films;
```

We can also use the count function to determine the number of rows in one or more columns.

```{sql}
SELECT COUNT(*)
FROM reviews;
```

We often want to count the number of non-missing values in a column, which we do by specifying the column to count.  We can then combine this with DISTINCT to determine the number of distinct or unique values in the column.

```{sql}
SELECT COUNT(*)
FROM people;
```


```{sql}

SELECT COUNT(birthdate)
FROM people;
```

```{sql}
SELECT COUNT(DISTINCT birthdate)
FROM people;
```


## Filtering

In SQL, the WHERE keyword allows you to filter based on both text and numeric values in a table. There are a few different comparison operators you can use:

* = equal
* <> not equal
* < less than
* > greater than
* <= less than or equal to
* >= greater than or equal to

So for instance, to select all films from 2016, we would use

```{sql}
SELECT *
FROM films
WHERE release_year = 2016 
LIMIT 10;
```
Or to count

```{sql}
SELECT COUNT(*)
FROM films
WHERE release_year < 2000; 
```

We can search for French lanaguage films

```{sql}
SELECT *
FROM films
WHERE language = 'French';
```

We can also add multiple conditions using the AND operator, which needs to be used for each new condition e.g.

```{sql}
SELECT *
FROM films
WHERE language = 'Spanish'
AND release_year > 2000
AND release_year < 2010;
```

In a similar way we can use the OR command.  If we have mutiple conditions we should use brackets e.g.

```{sql}
SELECT title, release_year
FROM films
WHERE release_year > 1989
AND release_year < 2000
AND (language = 'Spanish' OR language = 'French')
```

We can also use the between command to select values within a range

```{sql}
SELECT title, release_year
FROM films
WHERE release_year BETWEEN 1990 AND 2000
AND budget > 100000000
AND (language = 'Spanish' OR language = 'French');
```

Stringing together multiple WHERE and OR statements can become complex, and there is a function - IN - to make this easier

```{sql}
SELECT title, release_year
FROM films
WHERE release_year IN (1990, 2000)
AND duration > 120
LIMIT 25;
```

In SQL, NULL represents a missing or unknown value. You can check for NULL values using the expression IS NULL.  This can be useful for checking for valid nulls as show in the next example, or for checking invalid (missing) data.

If we wanted to list all the people without a death date, who presumbably are still alive (assuming 100% completeness) we would run:

```{sql}
SELECT name
FROM people
WHERE deathdate IS NULL
ORDER BY random() -- will cause a random selection to be made
LIMIT 15;
```

Or to count the number of films which don't have a language associated with them, we would have

```{sql}
SELECT count(*)
FROM films
WHERE language IS NULL;
```

We often have instances where we need to search within a column for a string of text.  There are two options

1. the LIKE operator can be used in a WHERE clause to search for a pattern in a column. To accomplish this, you use something called a wildcard as a placeholder for some other values. There are two wildcards you can use with LIKE:

The % wildcard will match zero, one, or many characters in text. For example, the following query matches companies like 'Data', 'DataC' 'DataCamp', 'DataMind', and so on:

> SELECT name
  FROM companies
  WHERE name LIKE 'Data%';


2. the _ wildcard will match a single character. For example, the following query matches companies like 'DataCamp', 'DataComp', and so on:

> SELECT name
  FROM companies
  WHERE name LIKE 'DataC_mp';
  
You can also use the NOT LIKE operator to find records that don't match the pattern you specify.

So for people whose names starts with a B we have

```{sql}
SELECT name 
FROM people
WHERE name LIKE 'B%'
LIMIT 10;
```

Or to get the names of people whose second letter is an r

```{sql}
SELECT name 
FROM people
WHERE name LIKE '_r%'
ORDER BY random()
LIMIT 10;
```

Or whose name does not start with an A

```{sql}
SELECT name 
FROM people
WHERE name NOT LIKE 'A%'
ORDER BY random()
LIMIT 10;
```

## Aggregate Functions

Often, you will want to perform some calculation on the data in a database. SQL provides a few functions, called aggregate functions, to help you out with this.  Some examples are:

* AVG() 
* MAX() 
* MIN()
* SUM()

```{sql}
SELECT SUM(duration)
FROM films;
```

```{sql}
SELECT AVG(duration)
FROM films;
```

```{sql}
SELECT MIN(duration)
FROM films;
```

```{sql}
SELECT MAX(duration)
FROM films;
```

Aggregate functions can be combined with the WHERE clause to gain further insights from your data.

```{sql}
SELECT SUM(gross)
FROM films
WHERE release_year >= 2000;
```

Or to get the average amount by all films starting with A

```{sql}
SELECT AVG(gross)
FROM films
WHERE title LIKE 'A%';
```

Or to get the amount grossed by the worst performing film in 1994.

```{sql}
SELECT MIN(gross)
FROM films
WHERE release_year = 1994;
```

Or get the amount grossed by the best performing film between 2000 and 2012, inclusive.

```{sql}
SELECT MAX(gross)
FROM films
WHERE release_year BETWEEN 2000 AND 2012;
```

In addition to using aggregate functions, you can perform basic arithmetic with symbols like +, -, *, and /.

NOTE: That if you use an integer as a value in a calculation, SQL will assume you want an integer back e.g.

> SELECT (4 / 3);

Will return 1

Where as adding decimal places

> SELECT (4.0 / 3.0);

Will result in a value of 1.33333r

Also, when you have multiple columns with similar functions things can get confusing e.g. 

> SELECT MAX(budget), MAX(duration)
  FROM films;

You'd end up with two columns named max.

To avoid situations like this, SQL allows you to do something called aliasing. Aliasing simply means you assign a temporary name to something. To alias, you use the AS keyword.

> SELECT MAX(budget) AS max_budget,
         MAX(duration) AS max_duration
  FROM films;

```{sql}
SELECT title, (gross - budget) AS net_profit
FROM films
LIMIT 10;
```

```{sql}
SELECT title, (duration / 60.0) AS duration_hours
FROM films
LIMIT 10;
```

```{sql}
SELECT AVG (duration / 60.0) AS avg_duration_hours
FROM films;
```

Note that in a culculation, only one of the numbers needs to have a decimal place, for the result to occur with a decimal place.

So if we are to calculate the death rate or percent, we would have

```{sql}
SELECT COUNT(deathdate) * 100.0 / COUNT(*) AS percentage_dead
FROM people;
```

Or to calculate the number of decades the film table covers

```{sql}
SELECT (MAX(release_year) - MIN(release_year)) / 10.0 AS number_of_decades
FROM films;
```

